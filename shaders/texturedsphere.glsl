#version 330in vec2 texCoords;out vec4 outColor;uniform float iGlobalTime;uniform vec2 iResolution;uniform sampler2D iChannel0;/*uniform mediump mat4 rotation;  // sphere rotation matrixuniform lowp vec4 lightPos;     // where the light is (assume sphere is at (0, 0, 0))uniform lowp float minLight;    // minimum light level*/const mat4 rotation = mat4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);const vec4 lightPos = vec4(1,0,0,1);const float minLight = 0.1;#define PIP2    1.5707963       // PI/2#define PI      3.1415629#define TWOPI   6.2831853       // 2PIvoid main(){  vec2 tc = 1-2*texCoords;    // make us round    mediump float d = tc.x * tc.x + tc.y * tc.y;    if (d > 1.0)        discard;    // we're in, compute the exact Z    mediump float z = sqrt(1.0 - d);    // get light intensity    mediump vec4 point = vec4(tc.xy, z, 1.0);    // rotate    point *= rotation;    lowp float l = clamp(dot(point, lightPos), minLight, 1.0);    // get texture coordinates (I believe this could be replaced with a    // precomputed texture lookup, if you need more performance)    mediump float x = (atan(point.x, point.z) + PI) / TWOPI,                  y = (asin(point.y) + PIP2) / PI;    // get texel and shade it    mediump vec4 texel = texture2D(iChannel0, vec2(x, y)) * vec4(l, l, l, 1.0);    // anti-aliasing   outColor = texel * (1.0 - smoothstep(0.985, 1.0, d));