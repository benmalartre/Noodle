#version 330in vec2 texCoords;out vec4 outColor;uniform float iGlobalTime;uniform vec2 iResolution;uniform vec3 iMouse;uniform sampler2D iChannel0;uniform mat4 view;const float PI = 3.1415;///All lava credit goes to: https://www.shadertoy.com/view/lslXRSvec3 light = vec3(-1, -1, 1.5);vec3 light_color = vec3(1, 1, 1);vec3 sphere = vec3(0, 0, 0);float sphere_size = 4;vec3 sphere_color = vec3(1, 1, 1);float hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }mat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}float noise( in vec2 x ){return texture2D(iChannel0, x*.01).x;}vec2 gradn(vec2 p){	float ep = .09;	float gradx = noise(vec2(p.x+ep,p.y))-noise(vec2(p.x-ep,p.y));	float grady = noise(vec2(p.x,p.y+ep))-noise(vec2(p.x,p.y-ep));	return vec2(gradx,grady);}//Spherical coordinates, very heavy deformation on the polesvec3 sphproj(in vec3 p){	//p = normalize(p);    vec2 sph = vec2(acos(p.y/length(p))/PI, atan(p.z,p.x)/PI*0.5);    return vec3(sph,0.0);}//vec3 extractCameraPos(mat4 m){	mat3 rotMat = mat3(m);  	vec3 d = m[3].xyz;   	vec3 retVec = -d * rotMat; 	 return retVec;}#define time iGlobalTime*0.1float flow(in vec2 p){	float z=2.;	float rz = 0.;	vec2 bp = p;	for (float i= 1.;i < 7.;i++ )	{		//primary flow speed		p += time*1.5;		//secondary flow speed (speed of the perceived flow)		bp += time*2.;		//displacement field (try changing time multiplier)		vec2 gr = gradn(i*p*.34+time*1.);		//rotation of the displacement field		gr*=makem2(time*10.-(0.05*p.x+0.03*p.y)*40.);		//displace the system		p += gr*.5;		//add noise octave		rz+= (sin(noise(p)*7.)*0.5+0.5)/z;		//blend factor (blending displaced system with base system)		//you could call this advection factor (.5 being low, .95 being high)		p = mix(bp,p,.8);		//intensity scaling		z *= 1.4;		//octave scaling		p *= 2.;		bp *= 1.9;	}	return rz;	}float atan2(in float y, in float x) {    bool s = (abs(x) > abs(y));    return mix(3.14159265358979/2.0 - atan(x,y), atan(y,x), s);}float raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {	radius = radius * radius;	float dt = dot(rdir, sp - rpos);	if (dt < 0.0) {		return -1.0;	}	vec3 tmp = rpos - sp;	tmp.x = dot(tmp, tmp);	tmp.x = tmp.x - dt*dt;	if (tmp.x >= radius) {		return -1.0;	}	dt = dt - sqrt(radius - tmp.x);	point = rpos + rdir * dt;	normal = normalize(point - sp);	return dt;}void main(void) {	light.xy = iMouse.xy / iResolution.xy * 2.0 - 1.0;	light.y = -light.y;	vec3 point; 	vec3 normal;	mat3 rot = mat3(view);	vec2 uv = texCoords.xy  * 2.0 - 1.0;	uv.x *= iResolution.x / iResolution.y;	uv.y = -uv.y;	vec3 ray = vec3(uv.x, uv.y, 1.0);	ray = normalize(ray);	//ray = rot * ray;	outColor = vec4(0.0);	float dist = raySphere(extractCameraPos(view), ray, sphere, sphere_size, point, normal);	if (dist > 0.0) {		vec3 uvs = sphproj(point);		outColor.xyz = texture2D(iChannel0, uvs.xy).xyz;	}	//outColor = vec4(flow(texCoords*100.0),0.0,0.0,1.0);}