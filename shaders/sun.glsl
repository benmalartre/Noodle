#version 330in vec2 texCoords;out vec4 outColor;uniform float iGlobalTime;uniform vec2 iResolution;uniform sampler2D iChannel0;// Based on:// - https://www.shadertoy.com/view/4dXGR4// - https://www.shadertoy.com/view/lsf3RH//Tweakablesconst float SIZE = 2;const float CORONA_SCALE = 0.5;const int CORONA_SAMPLES = 12;const float CORONA_SAMPLE_STEP = 1.5;const float ANIMTION_SPEED = 1.5;const vec3 BASE_COLOR = vec3(1, 0.45, 0.15);const float MIN_SPOT = 0.0;const float MAX_SPOT = 1.0;const float SPOT_INTENSITY = 0.55;float snoise(vec3 uv, float res){	const vec3 s = vec3(1.0, 100.0, 1000.0);		uv *= res;		vec3 uv0 = floor(mod(uv, res)) * s;	vec3 uv1 = floor(mod(uv + vec3(1.0), res)) * s;		vec3 f = fract(uv);    f = f * f * (3.0 - 2.0 * f);	vec4 v = vec4(uv0.x + uv0.y + uv0.z, uv1.x + uv0.y + uv0.z,		      	  uv0.x + uv1.y + uv0.z, uv1.x + uv1.y + uv0.z);	vec4 r = fract(sin(v * 0.1) * 1000.0);	float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);		r = fract(sin((v + uv1.z - uv0.z) * 0.1) * 1000.0);	float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);		return mix(r0, r1, f.z) * 2.0 - 1.0;}float body(in vec2 uv){	float brightness	= 0.25;	float radius		= 0.24 + brightness * 0.2;	float invRadius 	= 1.0/radius;		vec3 orange			= vec3( 0.8, 0.65, 0.3 );	vec3 orangeRed		= vec3( 0.8, 0.35, 0.1 );	float time		= iGlobalTime * ANIMTION_SPEED * 0.1;	float aspect	= iResolution.x / iResolution.y;	vec2 p 			= (-0.5 + uv);		float dist		= length(p);	vec3 starSphere		= vec3( 0.0 );		vec2 sp = -1.0 + 2.0 * uv;	sp *= (2.0 - brightness);  	float r = dot(sp, sp);	float f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;	if( dist < radius ){  		vec2 newUv; 		newUv.x = sp.x*f;  		newUv.y = sp.y*f;				vec3 texSample 	= texture2D( iChannel0, newUv ).rgb;		float uOff		= ( texSample.g * brightness * 4.5 + time );		vec2 starUV		= newUv + vec2( uOff, 0.0 );		starSphere		= texture2D( iChannel0, starUV ).rgb;	}	    return length(starSphere);}float corona(in vec2 p){    //Calculate the color intensity of this pixel (based on distance from center)	float color = (1.0 / CORONA_SCALE) * (SIZE - (length(6.0 * p)));	    //Calculate polar coordinate	vec3 coord = vec3(atan(p.x, p.y) / 6.2832, length(p) * 0.5, 0);        //Offset coordinate by time for animation    coord += vec3(0.0, -iGlobalTime * (ANIMTION_SPEED / 150.0), iGlobalTime * (ANIMTION_SPEED / 750.0));	    //Sum up samples	for(int i = 1; i <= CORONA_SAMPLES; i++)	{		float power = pow(2.0, float(i));		color += (1.5 / power) * snoise(coord, power * float(CORONA_SAMPLES) * CORONA_SAMPLE_STEP);	}        return max(color * CORONA_SCALE, 0.0);}void main(  ) {    //Correct for screen size and aspect ratio	vec2 p = -0.5 + texCoords ;	p.x *= iResolution.x/iResolution.y;	    //Calculate the color intensity of this pixel (based on distance from center)	float color = corona(p);    vec3 coronaColor = vec3(        clamp(color * BASE_COLOR.r, 0.0, 1.0),        clamp(pow(max(color, 0.0), 2.0) * BASE_COLOR.g, 0.0, 1.0),        clamp(pow(max(color, 0.0), 3.0) * BASE_COLOR.b, 0.0, 1.0)    );        //Calculate spots on the star body    float spots = mix((1.0 - SPOT_INTENSITY), 1.0, clamp(1.0 - body(p + 0.5), 0.0, 1.0));    vec3 spotColor = vec3(        clamp(spots * 1.0 / (1.0 - BASE_COLOR.r), 0.0, 1.0),        clamp(spots * 1.0 / (1.0 - BASE_COLOR.g), 0.0, 1.0),        clamp(spots * 1.0 / (1.0 - BASE_COLOR.b), 0.0, 1.0)	);        outColor = vec4(        coronaColor * spotColor,        1.0    );}