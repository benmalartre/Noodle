#version 330in vec2 texCoords;out vec4 outColor;uniform float iGlobalTime;uniform vec2 iResolution;uniform sampler2D iChannel0;uniform sampler2D iChannel1;uniform sampler2D iChannel2;//============================================// Dixuan Yang// Brown University//// CSCI 2240, course project// Feb 17th, 2016//============================================//============================================// globals & constants//============================================// camera parametersvec3 camera_pos, camera_tar, camera_dir;vec3 u, v, w;const vec3 up = vec3(0.0, 1.0, 0.0);// environmentfloat brightness;// motionvec3 sun_dir;vec3 movement;const vec3 building_top    = vec3(0.0, 3.0, 0.0);const vec3 building_bottom = vec3(0.0, 1.9, 0.0);// objects parametersconst int   bird_num = 1;const vec3  body_size = vec3(0.4, 0.3, 0.2);const vec2  funnel_size = vec2(0.04, 0.4);const float line_radius = 0.0;const float ambient_factor = 0.4;const float ambient_compensate = 0.2;const float bird_max_height = 3.0;// object colorsconst vec3 line_color       = vec3(0.3, 0.3,  0.5);const vec3 sun_color        = vec3(1.0, 0.7,  0.4);const vec3 sun_color_red    = vec3(1.0, 0.2,  0.2);const vec3 sky_color        = vec3(0.3, 0.6,  0.8);const vec3 sky_color_dark   = vec3(0.0, 0.1,  0.4);const vec3 cloud_color      = vec3(1.0, 0.95, 1.0);const vec3 cloud_color_dark = vec3(0.3, 0.25, 0.3);const vec3 roof_color       = vec3(0.6, 0.5,  0.3);const vec3 body_color       = vec3(0.5, 0.2,  0.1);const vec3 funnel_color     = vec3(0.0, 0.0,  0.5);const vec3 bird_color       = vec3(0.9, 0.8,  0.9);// colorsconst vec3 color_purple = vec3(0.761, 0.506, 0.835);const vec3 color_blue   = vec3(0.384, 0.667, 0.655);const vec3 color_yellow = vec3(0.961, 0.753, 0.196);const vec3 color_green  = vec3(0.624, 0.796, 0.361);const vec3 color_orange = vec3(0.953, 0.482, 0.318);const vec3 color_red    = vec3(0.886, 0.557, 0.616);// cloud parametersconst float cloud_max_height        = 2.0;const float cloud_min_height        = 0.0;const float cloud_amplitude         = 0.4;const float cloud_density_threshold = 0.001;const float cloud_max_alpha         = 0.99;// ray marching parametersconst int   max_step = 250;const float dist_per_step = 0.04;const float epsilon = 0.015;const float pi = 3.1415926536;//============================================// prototypes//============================================// backgroundvec3 meet_sky(in vec3 ray_dir, in vec2 uv);vec3 lens_flare(in vec2 uv);vec3 rainbow(in vec3 ray_dir);vec3 star(in vec2 uv);// all objects mapsbool object_divide_map(in vec3 position, in vec3 ray_dir, out vec3 color);bool building_map(in vec3 position, out vec3 color);bool bird_map(in vec3 position, out vec3 color);bool balloon_map(in vec3 position, in vec3 ray_dir, in vec3 center, in vec3 balloon_color, float radius, out vec3 color);bool balloon_group_map(in vec3 position, in vec3 ray_dir, out vec3 color);// objects distance & density functionfloat meet_sphere(in vec3 p, in float r);float meet_cone(in vec3 p, in vec3 c);float meet_roof(vec3 p, float h);float meet_box(in vec3 p, in vec3 b);float meet_cylinder(in vec3 p, in vec2 h);float meet_capsule(in vec3 p, in vec3 a, in vec3 b, float r);float meet_triangle(vec3 p, vec3 a, vec3 b, vec3 c);float meet_roundbox(in vec3 p, in vec3 b, float r);float cloud_density(in vec3 position);vec2  meet_building(in vec3 position);float meet_bird(in vec3 position, int index);// rendervec4 render(in vec3 ray_pos, in vec3 ray_dir, in vec2 uv);vec4 raymarch(in vec3 ray_pos, in vec3 ray_dir);// motion & environmentvoid motion_setup();void camera_setup();void environment_setup();void bird_motion(int index, out vec3 bird_pos, out vec3 bird_dir, out float phase);// mathfloat dot2(in vec3 v);vec2  hash(vec2 p);float hash(float n);float noise(in vec2 p);vec2  polar_convert(in vec3 position, in vec3 center, in float radius);vec2  compx(in vec2 v1, in vec2 v2);float smin(float a, float b, float k);vec3  bend(vec3 p);vec2  sd2Segment(vec3 a, vec3 b, vec3 p);//============================================// main function//============================================void main() {    // uv convert    vec2 uv = texCoords.xy;    vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1.0);    // setup environment    camera_setup();    motion_setup();    environment_setup();    // cast ray    vec3 ca_dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));    vec3 wd_dir = normalize(ca_dir.x * u + ca_dir.y * v - ca_dir.z * w);    // render    outColor = render(camera_pos, wd_dir, p);}//============================================// setup//============================================void camera_setup() {    float iTime = iGlobalTime * 0.8;    float tTime = iTime + 0.05;    float camera_radius = 5.0;    camera_pos = vec3(camera_radius * sin(0.16 * iTime), 4.0, camera_radius * cos(0.145 * iTime + .3));    camera_tar = vec3(0.0, 4.0, 0.0);    camera_dir = normalize(camera_tar - camera_pos);    w = -camera_dir;    u = normalize(cross(w, up));    v = normalize(cross(u, w));}void motion_setup() {    float iTime = iGlobalTime * 0.05;    movement = vec3(0.0, 1.0 * sin(iTime * 2.0), 0.0);    sun_dir = normalize(vec3(0.5 * cos(iTime) + 0.7, -0.5 * sin(iTime) * cos(iTime), 0.5 * sin(iTime)));}// must after the camera setup and motion setupvoid environment_setup() {	    // pure bright    if (sun_dir.y < -0.1) {        brightness = 1.0;        return;    }	    // pure dark    if (sun_dir.y > 0.1) {    	brightness = 0.0;        return;    }        // linear transition    brightness = 0.5 - 5.0 * sun_dir.y;}//============================================// render//============================================vec4 render(in vec3 ray_pos, in vec3 ray_dir, in vec2 uv) {    // sky and sun color as background    vec3 color = meet_sky(ray_dir, uv);    // cloud and build ray marching    vec4 march_color = raymarch(ray_pos, ray_dir);    // alpha blending (front view and sky)    color = color * (1.0 - march_color.a) + march_color.rgb;        return vec4(color, 1.0);}//============================================// ray marching//============================================vec4 raymarch(in vec3 ray_pos, in vec3 ray_dir) {    vec4 color = vec4(0.0);    float t = 0.0;    // integrate color while ray marching    for(int i = 0; i < max_step; ++ i) {                vec3 pos = ray_pos + t * ray_dir;                if (pos.y < cloud_min_height || color.a > cloud_max_alpha) break;        float density = cloud_density(pos);        vec3 object_color;        // ray has met an object, "alpha blend" object color with cloud color and stop marching        if (object_divide_map(pos, ray_dir, object_color)) {            color += vec4(object_color, 1.0) * (1.0 - color.a);            break;        }        if (density > cloud_density_threshold) {            // cloud color            vec3 cloud_color = mix(cloud_color, cloud_color_dark, density);            float sun_factor = min(max(dot(vec3(0.0, -1.0, 0.0), sun_dir - vec3(0.0, 0.2, 0.0)) * 6.3, 0.6), 1.25);            float alpha = density * 0.2;            // alpha blending (cloud and objects)            color += vec4(cloud_color * alpha * sun_factor, alpha) * (1.0 - color.a);        }        t += dist_per_step;    }    return clamp(color, 0.0, 1.0);}//============================================// background effects//============================================vec3 meet_sky(in vec3 ray_dir, in vec2 uv) {    float sun_intensity = max(dot(-ray_dir, sun_dir), 0.0);    // sky color    vec3 color = mix(sky_color_dark, sky_color, 1.0 - ray_dir.y) * max(brightness, ambient_compensate);    // add sun color    color += sun_color * min(pow(sun_intensity, 400.0) * 10.2, 1.0) * 0.315 +             sun_color * min(pow(sun_intensity, 14.9 ) * 1.2 , 1.0) * 0.45;    // add lens flare    color += lens_flare(uv);        // add rainbow    color += rainbow(ray_dir);        // add stars    color += star(uv);    return clamp(color, 0.0, 1.0);    }vec3 rainbow(in vec3 ray_dir) {        vec3 rainbow_dir = normalize(vec3(-0.4, -0.2, 0.0));    float theta = degrees(acos(dot(rainbow_dir, ray_dir)));    const float intensity = 0.30;		vec3 color_range = vec3(50.0, 53.0, 56.0);	// angle for red, green and blue    vec3 nd = clamp(1.0 - abs((color_range - theta) * 0.2), 0.0, 1.0);	vec3 color = (3.0 * nd * nd - 2.0 * nd * nd * nd) * intensity;        return color * max((brightness - 0.8) * 3.5, 0.0);}vec3 star(in vec2 uv) {            const float star_threshold = 0.97;    float xhash = hash(uv.x * 37.0);    float yhash = hash(uv.y * 57.0);    float star_val = fract(xhash + yhash);	    if (star_val > star_threshold) {		return vec3(pow((star_val - star_threshold) / (1.0 - star_threshold), 6.0)) * (1.0 - brightness);    }        return vec3(0.0);}vec3 lens_flare(in vec2 uv) {    vec3 color = vec3(0.0);    float sun_factor = dot(w, sun_dir);    const float max_inten = 1.3;    const float intensity = 0.021;    const float shininess = 7.0;    const float shininess1 = 10.0, shininess2 = 8.0, shininess3 = 4.0;    if (sun_factor > 0.0){      // which means sun is inside the screen        vec2 sun_uv = vec2(dot(sun_dir, u), dot(sun_dir, v));        vec2 uv_diff = uv - sun_uv;        uv_diff = uv_diff * (length(uv_diff));        sun_factor = pow(sun_factor, shininess);        float lensf1 = max(max_inten - length(uv_diff + sun_uv * 2.0) * 2.0, 0.0);        float lensf2 = max(max_inten - length(uv_diff + sun_uv * 0.5) * 4.0, 0.0);        float lensf3 = max(max_inten - length(uv_diff * 3.3 + sun_uv * 5.0 - uv * 2.5) * 1.2, 0.0);        color += sun_color_red * pow(lensf1, shininess1) * 12.0 +                 sun_color     * pow(lensf2, shininess2) * 4.0  +                 sun_color     * pow(lensf3, shininess3) * 12.0;    }    return clamp(color * sun_factor * intensity, 0.0, 1.0) * brightness;}//============================================// maps//============================================bool object_divide_map(in vec3 position, in vec3 ray_dir, out vec3 color) {        vec3 pos = position;    float height = building_top.y + movement.y;        if (pos.y > height && balloon_group_map(pos - movement, ray_dir, color)) return true;    if (pos.y <= height && building_map(pos - movement, color)) return true;    if (pos.y <= bird_max_height && bird_map(position, color)) return true;    return false;}bool building_map(in vec3 position, out vec3 color) {           vec2 ret = meet_building(position);        if (ret.x < epsilon) {                vec3 eps = vec3(0.01, 0.0, 0.0);                 // calculate normal at intersection point    	vec3 normal = normalize(vec3(        	meet_building(position + eps.xyy).x - meet_building(position - eps.xyy).x,            meet_building(position + eps.yxy).x - meet_building(position - eps.yxy).x,            meet_building(position + eps.yyx).x - meet_building(position - eps.yyx).x        ));                // calculate color        float diffuse_factor = max(dot(normal, -sun_dir) * brightness, ambient_compensate);        vec3 ambient_color, diffuse_color;                if (ret.y == 1.0) {				// roof        	ambient_color = texture2D(iChannel1, position.xz).rgb;            diffuse_color = roof_color;        } else if (ret.y == 2.0) {		// body            float theta = atan(position.z / position.x);            if (position.x < 0.0) theta += pi;        	ambient_color = texture2D(iChannel2, vec2(theta * 0.3, position.y)).rgb;            diffuse_color = body_color;        } else {						// funnel        	ambient_color = texture2D(iChannel0, position.xz).rgb;            diffuse_color = funnel_color;        }                color = ambient_factor * ambient_color + diffuse_factor * diffuse_color;        return true;    }        return false;}bool bird_map(in vec3 position, out vec3 color) {        for (int i = 0; i < bird_num; ++ i) {            	float dist = meet_bird(position, i);        	if (dist < epsilon) {                	vec3 eps = vec3(0.005, 0.0, 0.0);                	// calculate normal at intersection point    		vec3 normal = normalize(vec3(        		meet_bird(position + eps.xyy, i) - meet_bird(position - eps.xyy, i),            	meet_bird(position + eps.yxy, i) - meet_bird(position - eps.yxy, i),            	meet_bird(position + eps.yyx, i) - meet_bird(position - eps.yyx, i)        	));                	// calculate color        	float diffuse_factor = max(dot(normal, -sun_dir) * brightness, ambient_compensate);    		color = bird_color * diffuse_factor;        	return true;    	}    }        return false;}bool balloon_group_map(in vec3 position, in vec3 ray_dir, out vec3 color) {    // group different layers of balloons, some layers are near, while some are far    if (balloon_map(position, ray_dir, vec3( 0.1, 4.9,  0.0), color_purple, 0.3, color)) return true;    if (balloon_map(position, ray_dir, vec3( 0.2, 4.2,  0.0), color_green,  0.3, color)) return true;    if (balloon_map(position, ray_dir, vec3( 0.3, 4.1,  1.0), color_blue,   0.3, color)) return true;    if (balloon_map(position, ray_dir, vec3(-0.2, 4.7,  0.5), color_yellow, 0.3, color)) return true;    if (balloon_map(position, ray_dir, vec3(-0.3, 4.0, -0.5), color_red,    0.3, color)) return true;    if (balloon_map(position, ray_dir, vec3(-0.3, 5.0, -0.5), color_orange, 0.3, color)) return true;        return false;}bool balloon_map(in vec3 position, in vec3 ray_dir, in vec3 center, in vec3 balloon_color, float radius, out vec3 color) {    float dist_balloon = meet_sphere(position - center, radius);    if (dist_balloon < epsilon) {                vec3 normal = normalize(position - center);        vec3 reflect_ray = reflect(ray_dir, normal);        float diffuse_factor  = max(dot(normal, -sun_dir) * brightness, ambient_compensate);        float specular_factor = pow(max(dot(reflect_ray, -sun_dir), 0.0), 10.0) * 0.8 * brightness;                // use polar cordinates as uv to sample texture        vec2 uv = polar_convert(position, center, radius) * vec2(2.0, 1.0);        vec3 texture_color = texture2D(iChannel0, uv * 0.15).rgb;        color = ambient_factor * texture_color + diffuse_factor * balloon_color + specular_factor * sun_color;        color = clamp(color, 0.0, 1.0);        return true;            } else {        vec3 a = position - center;        vec3 b = building_top - center;        float h = clamp(dot(a, b) / dot(b, b), 0.0, 1.0);        vec3 normal = a - b * h;        float dist_line = length(normal) - line_radius;                // meet the line        if (dist_line < epsilon && dot(a, a) < dot(b, b)) {                        float diffuse_factor = max(dot(normalize(normal), -sun_dir) * brightness, 0.3);            color = mix(balloon_color, line_color, diffuse_factor) * diffuse_factor;            return true;        }    }        return false;}//============================================// objects distance function//============================================float meet_sphere(in vec3 p, in float r) {        return length(p) - r;}float meet_cone(in vec3 p, in vec3 c) {	    vec2 q = vec2(length(p.xz), p.y);    float d1 = -q.y - c.z;    float d2 = max(dot(q, c.xy), q.y);        return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);}float meet_capsule(in vec3 p, in vec3 a, in vec3 b, float r) {	    vec3 pa = p - a, ba = b - a;    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);        return length(pa - ba * h) - r;}float meet_triangle(vec3 p, vec3 a, vec3 b, vec3 c) {	    vec3 ba = b - a, pa = p - a;    vec3 cb = c - b, pb = p - b;    vec3 ac = a - c, pc = p - c;    vec3 nor = cross(ba, ac);        float f1 = sign(dot(cross(ba, nor), pa)) + sign(dot(cross(cb, nor), pb)) + sign(dot(cross(ac, nor), pc));    float f2 = min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),                       dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)),                   	   dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc));    float f3 = dot(nor, pa) * dot(nor, pa) / dot2(nor);        return sqrt(f1 < 2.0 ? f2 : f3);}float meet_roof(vec3 p, float h) {    p.y -= h + 0.1;    float k = dot(vec2(abs(p.z), p.y), vec2(0.7071067811865475));    float l = -p.y - h;    float w = abs(p.x * 0.9) - h;    return max(k, max(l, w));}float meet_box(in vec3 p, in vec3 b) {    	return length(max(abs(p) - b, 0.0));}float meet_cylinder(in vec3 p, in vec2 h) {        vec2 d = abs(vec2(length(p.xz), p.y)) - h;    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));}float meet_roundbox(in vec3 p, in vec3 b, float r) {        return length(max(abs(p) - b, 0.0)) - r;}float cloud_density(in vec3 position) {    // let cloud move only in z directoin    vec2 xz_move = position.xz - vec2(0.0, 1.0) * iGlobalTime;    // expand in xz    float density = noise(xz_move * 0.7);           // limit the height of cloud    return clamp(cloud_max_height - position.y + cloud_amplitude * density, 0.0, 1.0);}vec2 meet_building(in vec3 position) {        vec3 offset;    vec2 ret = vec2(1.0, 0.0);        // meet house roof    offset = building_top - vec3(0.0, 0.5, 0.0);    ret = compx(ret, vec2(meet_roof(position - offset, 0.4), 1.0));        // meet house body    offset = building_top + vec3(0.0, -0.65, 0.0);    ret = compx(ret, vec2(meet_box(position - offset, body_size), 2.0));   	    // meet house funnel    offset = building_top + vec3(0.2, 0.0, -0.15);    ret = compx(ret, vec2(meet_cylinder(position - offset, funnel_size), 3.0));        return ret;}float meet_bird(in vec3 position, int index) {    // calculate bird's position and direction in world space    float phase = 0.0;    vec3 bird_pos, bird_dir;    bird_motion(index, bird_pos, bird_dir, phase);    vec3 pos = position - bird_pos;		// object space to world space        // object space    float dist_body = 1.0;    float h = 0.0;    vec3 a = vec3(0.0);    vec3 axis_point = a;    vec3 p, d;        // body    for (int i = 0; i < 5; ++ i) {    	        float moved = float(i) / 5.0;        float stepf = 0.3;        if (i == 0) stepf = 0.25;	// head        if (i == 4) stepf = 0.45;	// tail        vec3 b = a + stepf * bird_dir;                vec2 dist2 = sd2Segment(a, b, pos);                if (dist2.x < dist_body) {        	dist_body = dist2.x;            h = moved + dist2.y / 5.0;            axis_point = a + (b - a) * dist2.y;        }                // get wings position        if (i == 1) {            p = b;            d = b - a;        }                a = b;    }        float radius = 0.001 + h * pow(1.0 - h, 2.0) / 2.0;    dist_body = distance(pos, axis_point) - radius;    // wings    vec3 wing_w = normalize(d);	// direction of the axis    vec3 wing_u = cross(wing_w, up);    vec3 wing_v = cross(wing_w, wing_u);        vec3 wing_pos = pos - p;	// translation        // transform to wing space coordinate    wing_pos = wing_pos.x * wing_u + wing_pos.y * wing_v + wing_pos.z * wing_w;        // symmetric with respect to the x-axis in wing space    wing_pos.x = abs(wing_pos.x);    // wings motion, it's a sin wave    wing_pos.y += sin(distance(pos, axis_point) * phase);        // meet round box    float dist_wing = meet_roundbox(wing_pos, vec3(0.53, 0.001, 0.33), 0.001);        // clap the wings by circles    float dist1 = length(wing_pos.xz) - 0.5;				// circle 1    float dist2 = -length(wing_pos.xz - vec2(0.3)) + 0.4;	// circle 2    dist_wing = max(max(dist_wing, dist1), dist2);	return smin(dist_body, dist_wing, 0.07);}void bird_motion(int index, out vec3 bird_pos, out vec3 bird_dir, out float phase) {	        float bTime = iGlobalTime * 0.6;    phase = 0.5 * sin(bTime * 3.0);    float radius = 2.0;    float amp = 0.8; 	float h = 1.5;    float speed = 1.0 + 0.4 * sin(bTime);    bird_pos = vec3(radius * sin(bTime), h + amp * sin(bTime), radius * cos(bTime));    vec3 pos_next = vec3(radius * sin(bTime + 0.1), h + amp * sin(bTime + 0.1), radius * cos(bTime + 0.1));    bird_dir = -normalize(pos_next - bird_pos) * speed;}//============================================// math//============================================float dot2(in vec3 v) {        return dot(v, v);}vec2 hash(vec2 p) {    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);}float hash(float n) {    	return fract((1.0 + cos(n)) * 415.92653);}// 2D simplex noise functionfloat noise(in vec2 p) {    const float K1 = 0.366025404;    const float K2 = 0.211324865;    vec2 i = floor(p + (p.x + p.y) * K1);    vec2 a = p - i + (i.x + i.y) * K2;    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);    vec2 b = a - o + K2;    vec2 c = a - 1.0 + 2.0 * K2;    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));    return dot(n, vec3(70.0));}vec2 polar_convert(in vec3 position, in vec3 center, in float radius) {        vec3 diff = position - center;        float phi = acos(diff.y / radius);    float theta = atan(diff.z / diff.x);    if (diff.x < 0.0) theta += pi;        return vec2(phi, theta);}vec2 compx(in vec2 v1, in vec2 v2) {	    return v1.x < v2.x ? v1 : v2;}float smin(float a, float b, float k) {    	float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);	return mix(b, a, h) - k * h * (1.0 - h);}vec2 sd2Segment(vec3 a, vec3 b, vec3 p) {    	vec3 pa = p - a;	vec3 ba = b - a;	float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);	vec3 v = pa - ba * t;    	return vec2(dot(v, v), t);}vec3 bend(vec3 p) {    	float c = cos(20.0 * p.y);    float s = sin(20.0 * p.y);    mat2 m = mat2(c, -s, s, c);        return vec3(m * p.xy, p.z);}