#version 330in vec2 texCoords;out vec4 outColor;uniform float iGlobalTime;uniform vec2 iResolution;// camera attributes// cameraDirection and cameraUp MUST be normalized// (ie. their length must be equal to 1)const vec3 cameraPosition = vec3(0.0, 0.0, 10.0);const vec3 cameraDirection = vec3(0.0, 0.0, -1.0);const vec3 cameraUp = vec3(0.0, 1.0, 0.0);// ray computation varsconst float PI = 3.14159265359;const float fov = 50.0;const float fovx = PI * fov / 360.0;float fovy = fovx * iResolution.y/iResolution.x;float ulen = tan(fovx);float vlen = tan(fovy);float distanceToNearestSurface(vec3 p){    return length(p) - 1.0;}bool intersectsWithWorld(vec3 p, vec3 dir){  	float dist = 0.0;    float nearest = 0.0;    bool hit = false;    for(int i = 0; i < 20; i++){        float nearest = distanceToNearestSurface(p + dir*dist);        if(nearest < 0.01){            hit = true;            break;        }        dist += nearest;    }    return hit;}void main(  ){    vec2 uv = texCoords;///iResolution.xy;      // generate the ray for this pixel    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);    vec3 nright = normalize(cross(cameraUp, cameraDirection));    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;    vec3 rayDirection = normalize(pixel - cameraPosition);        float collidedWithWorld = 0.0;    if(intersectsWithWorld(cameraPosition, rayDirection))        collidedWithWorld = 1.0;    	outColor = vec4(collidedWithWorld, 0.0, 0.0, 1.0);