#version 330precision highp float;in vec2 texCoords;out vec4 outColor;uniform float iGlobalTime;uniform vec2 iResolution;uniform vec3 iMouse;uniform sampler2D iChannel0;const float PI = 3.1415;vec3 light = vec3(-1, -1, 1.5);vec3 light_color = vec3(1, 1, 1);vec3 sphere = vec3(0, 0, 2);float sphere_size = 0.4;vec3 sphere_color = vec3(1, 1, 1);vec3 sphere2 = vec3(1,1,3);float sphere_size2 = 0.1;vec3 sphere_color2 = vec3(1, 1, 1);float raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {	radius = radius * radius;	float dt = dot(rdir, sp - rpos);	if (dt < 0.0) {		return -1.0;	}	vec3 tmp = rpos - sp;	tmp.x = dot(tmp, tmp);	tmp.x = tmp.x - dt*dt;	if (tmp.x >= radius) {		return -1.0;	}	dt = dt - sqrt(radius - tmp.x);	point = rpos + rdir * dt;	normal = normalize(point - sp);	return dt;}void main(  ) {	light.xy = vec2(0,1);	light.y = -light.y;	vec3 point; 	vec3 normal;	vec3 point2;	vec3 normal2;	vec2 uv = texCoords.xy * 2.0 - 1.0;	uv.x *= iResolution.x / iResolution.y;	uv.y = -uv.y;	vec3 ray = vec3(uv.x, uv.y, 1.0);	ray = normalize(ray);	outColor = vec4(0.0);		float dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);	float dist2 = raySphere(vec3(0.0), ray, sphere2, sphere_size2, point2, normal2);	if (dist > 0.0 ) {		vec3 tmp = normalize(light - sphere);		float u = atan(normal.z, normal.x) / PI+ iGlobalTime*0.01;		float v = asin(normal.y) / PI*2+0.5 ;		outColor.xyz = vec3(dot(tmp, normal)) * light_color * sphere_color * texture2D(iChannel0, vec2(u, v)).xyz;	}	if(dist2>0.0){		vec3 tmp = normalize(light - sphere2);		float u = atan(normal2.z, normal2.x) / PI+ iGlobalTime*0.01;		float v = asin(normal2.y) / PI*2+0.5 ;		outColor.xyz = vec3(dot(tmp, normal2)) * light_color * sphere_color * texture2D(iChannel0, vec2(u, v)).xyz;	}}