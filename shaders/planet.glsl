#version 330in vec2 texCoords;out vec4 outColor;uniform float iGlobalTime;uniform vec2 iResolution;uniform vec3 iMouse;uniform sampler2D iChannel0;///All lava credit goes to: https://www.shadertoy.com/view/lslXRSvec3 light = vec3(-1, -1, 1.5);vec3 light_color = vec3(1, 1, 1);vec3 sphere = vec3(0, 0, 2);float sphere_size = 1.3;vec3 sphere_color = vec3(1, 1, 1);float hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }mat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}float noise( in vec2 x ){return texture2D(iChannel0, x*.01).x;}vec2 gradn(vec2 p){	float ep = .09;	float gradx = noise(vec2(p.x+ep,p.y))-noise(vec2(p.x-ep,p.y));	float grady = noise(vec2(p.x,p.y+ep))-noise(vec2(p.x,p.y-ep));	return vec2(gradx,grady);}#define time iGlobalTime*0.1float flow(in vec2 p){	float z=2.;	float rz = 0.;	vec2 bp = p;	for (float i= 1.;i < 7.;i++ )	{		//primary flow speed		p += time*1.5;		//secondary flow speed (speed of the perceived flow)		bp += time*2.;		//displacement field (try changing time multiplier)		vec2 gr = gradn(i*p*.34+time*1.);		//rotation of the displacement field		gr*=makem2(time*10.-(0.05*p.x+0.03*p.y)*40.);		//displace the system		p += gr*.5;		//add noise octave		rz+= (sin(noise(p)*7.)*0.5+0.5)/z;		//blend factor (blending displaced system with base system)		//you could call this advection factor (.5 being low, .95 being high)		p = mix(bp,p,.8);		//intensity scaling		z *= 1.4;		//octave scaling		p *= 2.;		bp *= 1.9;	}	return rz;	}float raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {	radius = radius * radius;	float dt = dot(rdir, sp - rpos);	if (dt < 0.0) {		return -1.0;	}	vec3 tmp = rpos - sp;	tmp.x = dot(tmp, tmp);	tmp.x = tmp.x - dt*dt;	if (tmp.x >= radius) {		return -1.0;	}	dt = dt - sqrt(radius - tmp.x);	point = rpos + rdir * dt;	normal = normalize(point - sp);	return dt;}void main(void) {	light.xy = iMouse.xy / iResolution.xy * 2.0 - 1.0;	light.y = -light.y;	vec3 point; 	vec3 normal;	vec2 uv = texCoords.xy  * 2.0 - 1.0;	uv.x *= iResolution.x / iResolution.y;	uv.y = -uv.y;	vec3 ray = vec3(uv.x, uv.y, 1.0);	ray = normalize(ray);	outColor = vec4(0.0);	float dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);	if (dist > 0.0) {		vec3 tmp = normalize(light - sphere);		float u = atan(normal.z, normal.x) / 3.1415*2.0;		float v = asin(normal.y) / 3.1415*2.0 + 0.5;		float rz = flow(vec2(u*5.0,v*5.0));		vec3 col = vec3(.2,0.07,0.01)/rz;		col=pow(col,vec3(1.4));		outColor.xyz = col;//vec3(dot(tmp, normal)) * light_color * sphere_color * col;	}.0 );        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );    }        return f * col_star;}vec3 doMainStar( in vec2 uv, in vec2 sp){    float t = atan( uv.x - sp.x, uv.y - sp.y );    float n = 2.0 + noise( vec3( 10.0 * t, iGlobalTime, 0.0 ) );    float d = length( uv - sp ) * 25.0;    return ( ( 1.0 + n ) / ( d * d * d ) ) * col_star;}float doCastSphere( in vec3 p, in vec3 rd ){    float b = dot( p, rd );    float c = dot( p, p ) - 1.0;        float f = b * b - c;    if( f >= 0.0 )    {        return -b - sqrt( f );    }    return -1.0;}vec3 doMaterial( in vec3 pos ){    vec2 uv;    uv.x = atan( pos.x, pos.z );    uv.y = asin( pos.y );    return distort( map( uv ) );}vec3 doLighting( in vec3 n, in vec3 c, in vec3 rd, in vec3 rdc ){    vec3  l   = normalize( pos_star + 2.0 * ( pos_star - dot( pos_star, rdc ) * rdc ) );    float ndl = dot( n, l );    float ndr = dot( n, -rd );    float ldr = dot( l, rd );    float f   = max( ndl, 0.0 ) + 0.002;    float g   = ldr * smoothstep( 0.0, 0.1, ndr ) * pow( 1.0 - ndr, 10.0 );    return clamp( f * c + g * col_star, 0.0, 1.0 );}float doFlare( in vec2 uv, in vec2 dir, float s ){    float d = length( uv - dot( uv, dir ) * dir );    float f = 0.0;    f += max( pow( 1.0 - d, 128.0 ) * ( 1.0   * s - length( uv ) ), 0.0 );    f += max( pow( 1.0 - d,  64.0 ) * ( 0.5   * s - length( uv ) ), 0.0 );    f += max( pow( 1.0 - d,  32.0 ) * ( 0.25  * s - length( uv ) ), 0.0 );    f += max( pow( 1.0 - d,  16.0 ) * ( 0.125 * s - length( uv ) ), 0.0 );    return f;}float doLensGlint( in vec2 uv, in vec2 c, float r, float w ){    float l = length( uv - c );    return length( c ) * smoothstep( 0.0, w * r, l ) * ( 1.0 - smoothstep( w * r, r, l ) );}vec3 render( in vec2 uv, in CameraInfo ci ){    // create view ray    vec3 rd  = ci.m * normalize( vec3( uv, 1.0 ) );    vec3 rdc = ci.m * vec3( 0.0, 0.0, 1.0 );        // background stars    vec3 c = doBackgroundStars( rd );        // main star    vec3 cp = ci.mInv * (pos_star - ci.pos);    vec2 sp = cp.xy / cp.z;    if( cp.z > 0. )    {        c += doMainStar( uv, sp );    }        // planet    float t = doCastSphere( ci.pos, rd );    if( t > 0.0 )    {        vec3 pos = ci.pos + t * rd;        vec3 nor = normalize( pos );        c = doMaterial( pos );        c = doLighting( nor, c, rd, rdc );    }        // lens flare    if( cp.z > 0.0 && sp.x > -1.0 && sp.x < 1.0 )    {        float oc = smoothstep( 0.35, 0.4, length( sp ) );        float f = 0.0;        f += doFlare( uv - sp, vec2( 1.,0. ), oc );        f += oc * 0.05 * doLensGlint( uv, -0.4 * sp, 0.2, 0.92 );        f += oc * 0.09 * doLensGlint( uv, -0.8 * sp, 0.3, 0.95 );        f += oc * 0.04 * doLensGlint( uv, -1.1 * sp, 0.06, 0.8 );        c += f * col_star;    }        return c;}CameraInfo doCamera( in vec3 pos, in vec3 dir ){    CameraInfo ci;        vec3 ww = dir;    vec3 uu = normalize( cross( ww, world_up ) );    vec3 vv = normalize( cross( uu, ww ) );    mat3 m = mat3( uu, vv, ww );    mat3 mInv = mat3( uu.x, vv.x, ww.x,                      uu.y, vv.y, ww.y,                      uu.z, vv.z, ww.z );        ci.pos = pos;    ci.dir = dir;    ci.m = m;    ci.mInv = mInv;        return ci;}void main (){    vec2 uv = texCoords.xy - 0.5;    uv.x *= iResolution.x / iResolution.y;        vec2 m = iMouse.xy / iResolution.xy;        // camera default movement    float cx = cos( 0.1 * iGlobalTime + 3.55 );    float sx = sin( 0.1 * iGlobalTime + 3.55 );    float cy = 0.;        // camera mouse movement    if( iMouse.z > 0. )    {        cx = cos( 10. * m.x );        sx = sin( 10. * m.x );        cy = cos( 3.2 * m.y );    }        // camera position/direction    vec3 camPos = 2. * vec3( cx - sx, cy, sx + cx );    vec3 camDir = normalize( -camPos );    // render scene    vec3 c = render( uv, doCamera( camPos, camDir ) );    //vec3 c = vec3( distort( map( uv ) ) );    //vec3 c = vec3( fbm( map( uv ), iGlobalTime ) );        // gamma correction    c = pow( c, vec3( 0.4545 ) );        outColor = vec4( c, 1.0 );}}}osition/direction    vec3 camPos = 2. * vec3( cx - sx, cy, sx + cx );    vec3 camDir = normalize( -camPos );    // render scene    vec3 c = render( uv, doCamera( camPos, camDir ) );    //vec3 c = vec3( distort( map( uv ) ) );    //vec3 c = vec3( fbm( map( uv ), iGlobalTime ) );        // gamma correction    c = pow( c, vec3( 0.4545 ) );        outColor = vec4( c, 1.0 );}
    vec3 c = render( uv, doCamera( camPos, camDir ) );
    //vec3 c = vec3( distort( map( uv ) ) );
    //vec3 c = vec3( fbm( map( uv ), iGlobalTime ) );
    
    // gamma correction
    c = pow( c, vec3( 0.4545 ) );
    
    outColor = vec4( c, 1.0 );
}
