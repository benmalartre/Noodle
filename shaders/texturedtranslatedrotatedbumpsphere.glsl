// Written by GLtracy#version 330uniform float iGlobalTime;uniform vec2 iResolution;uniform sampler2D iChannel0;uniform sampler2D iChannel1;uniform mat4 view;in vec2 texCoords;out vec4 fragColor;// Written by GLtracy// math constconst float PI = 3.14159265359;const float PI2 = PI*0.5;const float TWOPI = 2*PI;const float DEG_TO_RAD = PI / 180.0;const float MAX = 10000.0;// scatter constconst float K_R = 0.05;const float K_M = 0.0025;const float E = 14.3; 						// light intensityconst vec3  C_R = vec3( 0.3, 0.7, 1.0 ); 	// 1 / wavelength ^ 4const float G_M = -0.85;					// Mie gconst float R = 1.6;const float R_INNER =1.4;const float SCALE_H = 4.0 / ( R - R_INNER );const float SCALE_L = 1.0 / ( R - R_INNER );const int NUM_OUT_SCATTER = 10;const float FNUM_OUT_SCATTER = 10.0;const int NUM_IN_SCATTER = 10;const float FNUM_IN_SCATTER = 10.0;const int star_iterations = 3;const vec3 col_star = vec3( 0.77,1.0, 1.0 );const vec3 pos_star = vec3( 0.0, 0.0, 0.0 );const vec3 world_up = vec3( 0.0, 1.0, 0.0 );#define EPS 0.0001#define SAMPLES 8#define OFFSET_X .005#define OFFSET_Y .005#define DEPTH	  15.vec3 sample(float x, float y, in vec2 uv){	return texture2D(iChannel0, uv + vec2(x,y)).xyz;}float luminance(vec3 c){	return dot(c, vec3(.2126, .7152, .0722));}vec3 normal(in vec2 uv){	float R = abs(luminance(sample( OFFSET_X,0., uv)));	float L = abs(luminance(sample(-OFFSET_X,0., uv)));	float D = abs(luminance(sample(0., OFFSET_Y, uv)));	float U = abs(luminance(sample(0.,-OFFSET_Y, uv)));				 	float X = (L-R) * .5;	float Y = (U-D) * .5;	return normalize(vec3(X, Y, 1. / DEPTH));}struct Ray {    vec3 o; //origin    vec3 d; //direction (should always be normalized)};struct Sphere {    vec3 pos;   //center of sphere position    mat3 rot;    float rad;  //radius    vec4 col;   //surface color};// angle : pitch, yawmat3 rot3xy( vec2 angle ) {	vec2 c = cos( angle );	vec2 s = sin( angle );		return mat3(		c.y      ,  0.0, -s.y,		s.y * s.x,  c.x,  c.y * s.x,		s.y * c.x, -s.x,  c.y * c.x	);}float rrad = 1.35;float rspeed = 0.01*sin(0.001*iGlobalTime)+1.0;//Sphere earth = Sphere(vec3(rrad*cos(rspeed*iGlobalTime), 1.0, rrad*sin(rspeed*iGlobalTime)),1.0, vec4(0.7, 0.9, 0.0, 1.0));mat3 ER = rot3xy( vec2 (0,iGlobalTime*0.01)) ;Sphere earth = Sphere(vec3(5.0,2.0,0.0),ER,1.0,vec4(1.0));/* ---------- Object intersection functions ---------- */float intersectSphere(in Ray ray, in Sphere sphere){    vec3 oc = ray.o - sphere.pos;    float b = 2.0 * dot(ray.d, oc);    float c = dot(oc, oc) - sphere.rad*sphere.rad;    float disc = b * b - 4.0 * c;    if (disc < 0.0)        return -1.0;    // compute q as described above    float q;    if (b < 0.0)        q = (-b - sqrt(disc))/2.0;    else        q = (-b + sqrt(disc))/2.0;    float t0 = q;    float t1 = c / q;    // make sure t0 is smaller than t1    if (t0 > t1) {        // if t0 is bigger than t1 swap them around        float temp = t0;        t0 = t1;        t1 = temp;    }    // if t1 is less than zero, the object is in the ray's negative direction    // and consequently the ray misses the sphere    if (t1 < 0.0)        return -1.0;    // if t0 is less than zero, the intersection point is at t1    if (t0 < 0.0) {        return t1;    } else {        return t0;     }}vec3 extractCameraPos(mat4 m){	mat3 rotMat = mat3(m);  	vec3 d = m[3].xyz;   	vec3 retVec = -d * rotMat; 	 return retVec;}float hash( float n ) { return fract(sin(n)*123.456789); }vec2 rotate( in vec2 uv, float a){    float c = cos( a );    float s = sin( a );    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );}float noise( in vec3 p ){    vec3 fl = floor( p );    vec3 fr = fract( p );    fr = fr * fr * ( 3.0 - 2.0 * fr );    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );}float fbm( in vec2 p, float t ){    float f;    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;    f += 0.0625 * noise( vec3( p, t ) );    return f;}vec3 doBackgroundStars( in vec3 dir ){    vec3 n  = abs( dir );    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x:               ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:                                           dir.xy / dir.z;        float f = 0.0;        for( int i = 0 ; i < star_iterations; ++i )    {        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );                float t = 1. * uv.x * uv.y +iGlobalTime;        vec2 u = cos( 100 * uv ) * fbm( 66. * uv, 0.01 );        f += smoothstep( 0.5, 0.7, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );    }        return f * col_star;}//Spherical coordinates, very heavy deformation on the polesvec3 sphproj(in vec3 p){	//p = normalize(p);    //vec2 sph = vec2(acos(p.y/length(p))/PI, atan(p.z,p.x)/PI*0.5);    //return vec3(sph,0.0);mediump float u = -(atan(p.x, p.z) + PI) / TWOPI,                  v= (asin(p.y/length(p)) + PI2) / PI;	return vec3(-u,-v,0.0);}// ray directionvec3 ray_dir( float fov, vec2 size, vec2 pos ) {	vec2 xy = pos - size * 0.5;	float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );		float z = size.y * 0.5 * cot_half_fov;		return normalize( vec3( xy, -z ) );}// ray intersects sphere// e = -b +/- sqrt( b^2 - c )vec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {	float b = dot( p, dir );	float c = dot( p, p ) - r * r;		float d = b * b - c;	if ( d < 0.0 ) {		return vec2( MAX, -MAX );	}	d = sqrt( d );		return vec2( -b - d, -b + d );}// Mie// g : ( -0.75, -0.999 )//      3 * ( 1 - g^2 )               1 + c^2// F = ----------------- * -------------------------------//      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)float phase_mie( float g, float c, float cc ) {	float gg = g * g;		float a = ( 1.0 - gg ) * ( 1.0 + cc );	float b = 1.0 + gg - 2.0 * g * c;	b *= sqrt( b );	b *= 2.0 + gg;			return 1.5 * a / b;}// Reyleigh// g : 0// F = 3/4 * ( 1 + c^2 )float phase_reyleigh( float cc ) {	return 0.75 * ( 1.0 + cc );}float density( vec3 p ){	return exp( -( length( p ) - R_INNER ) * SCALE_H );}float optic( vec3 p, vec3 q ) {	vec3 step = ( q - p ) / FNUM_OUT_SCATTER;	vec3 v = p + step * 0.5;		float sum = 0.0;	for ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {		sum += density( v );		v += step;	}	sum *= length( step ) * SCALE_L;		return sum;}vec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {	float len = ( e.y - e.x ) / FNUM_IN_SCATTER;	vec3 step = dir * len;	vec3 p = o + dir * e.x;	vec3 v = p + dir * ( len * 0.5 );	vec3 sum = vec3( 0.0 );	for ( int i = 0; i < NUM_IN_SCATTER; i++ ) {		vec2 f = ray_vs_sphere( v, l, R );		vec3 u = v + l * f.y;				float n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );				sum += density( v ) * exp( -n * ( K_R * C_R + K_M ) );		v += step;	}	sum *= len * SCALE_L;		float c  = dot( dir, -l );	float cc = c * c;		return sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E;}void main(){	// default ray dir	vec3 dir = ray_dir( 45.0,vec2(1.0,1.0), texCoords.xy );	mat3 rot = mat3(inverse(view));	dir = rot * dir;	// default ray origin	//vec3 eye = vec3( 0.0, 0.0, 5.0 );	vec3 eye =  extractCameraPos(view);	Ray ray = Ray(eye, normalize(dir));	float t = intersectSphere(ray, earth);	if(t>EPS){		vec3 pos = ray.o + t*ray.d;		//pos = earth.rot * pos;		vec3 norm = normalize((pos - earth.pos)/earth.rad);		norm = earth.rot*norm;		vec2 uvs = sphproj(norm).xy;		vec3 n = normal(uvs);		float l = dot(n, vec3(0,1,0));		fragColor = texture2D(iChannel0,uvs)+vec4(l,l,l,1)*0.15;		//fragColor = texture2D(iChannel1,uvs);		//fragColor = vec4(norm,1);	}	/*	// rotate camera	mat3 rot = mat3(inverse(view));	// rot3xy( vec2( 0.0, iGlobalTime * 0.5 ) );	dir = rot * dir;	//eye = rot * eye;		// sun light dir	vec3 l = vec3( 0, 1, 0 );			  	vec2 e = ray_vs_sphere( eye, dir, R );	if ( e.x > e.y ) {		//discard;	}	fragColor = vec4(0.0,0.0,0.0,1.0);	vec2 f = ray_vs_sphere( eye, dir, R_INNER );	e.y = min( e.y, f.x );	//float t = iSphere(eye,dir,R_INNER);vec3 col =  doBackgroundStars(dir );//   if (f.y >0.)    {    	vec3 pos = eye+dir*f.x;    	 //col = texture2D(iChannel0,sphproj(pos).xy).xyz;	vec2 uvs = sphproj(pos).xy;	col = texture2D(iChannel0,uvs).xyz;	vec3 d =normalize(l-pos);	vec3 n = normalize(pos);	float x = dot(pos,l);	col *= x;    }	//vec3 I = in_scatter( eye, dir, e, l );		fragColor = vec4( col, 1.0 );*/}