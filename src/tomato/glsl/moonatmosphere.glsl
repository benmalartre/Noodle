// Original code by GLtracy#version 330uniform float iGlobalTime;uniform vec2 iResolution;uniform mat4 view;uniform vec3 position;uniform float inner_radius;uniform float outer_radius;uniform mat3 rotation;uniform vec3 color;uniform sampler2D texture;uniform vec3 sun_position;in vec2 texCoords;out vec4 fragColor;// math constconst float PI = 3.14159265359;const float PI2 = PI*0.5;const float TWOPI = 2*PI;const float DEG_TO_RAD = PI / 180.0;const float MAX = 10000.0;const int star_iterations = 3;const vec3 col_star = vec3( 0.77,1.0, 1.0 );const vec3 pos_star = vec3( 0.0, 0.0, 0.0 );const vec3 world_up = vec3( 0.0, 1.0, 0.0 );#define EPS 0.0001#define SAMPLES 8#define OFFSET_X .005#define OFFSET_Y .005#define DEPTH	  15.// scatter constconst float K_R = 0.166;const float K_M = 0.0025;const float E = 3.3; 						// light intensityconst vec4  C_R = vec4( 0.3, 0.7, 1.0,1.0 ); 	// 1 / wavelength ^ 4const float G_M = -0.85;					// Mie gfloat R = outer_radius;float R_INNER = inner_radius;float SCALE_H = 4.0 / ( R - R_INNER );float SCALE_L = 1.0 / ( R - R_INNER );const int NUM_OUT_SCATTER = 1;const float FNUM_OUT_SCATTER = 1.0;const int NUM_IN_SCATTER = 1;const float FNUM_IN_SCATTER = 1.0;vec3 sample(float x, float y, in vec2 uv){	return texture2D(texture, uv + vec2(x,y)).xyz;}float luminance(vec3 c){	return dot(c, vec3(.2126, .7152, .0722));}vec3 normal(in vec2 uv){	float R = abs(luminance(sample( OFFSET_X,0., uv)));	float L = abs(luminance(sample(-OFFSET_X,0., uv)));	float D = abs(luminance(sample(0., OFFSET_Y, uv)));	float U = abs(luminance(sample(0.,-OFFSET_Y, uv)));				 	float X = (L-R) * .5;	float Y = (U-D) * .5;	return normalize(vec3(X, Y, 1. / DEPTH));}struct Ray {    vec3 o; //origin    vec3 d; //direction (should always be normalized)};struct Sphere {    vec3 pos;   //center of sphere position    mat3 rot;    float rad;  //radius    vec4 col;   //surface color};// angle : pitch, yawmat3 rot3xy( vec2 angle ) {	vec2 c = cos( angle );	vec2 s = sin( angle );		return mat3(		c.y      ,  0.0, -s.y,		s.y * s.x,  c.x,  c.y * s.x,		s.y * c.x, -s.x,  c.y * c.x	);}// ray intersects sphere// e = -b +/- sqrt( b^2 - c )vec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {	highp float b = dot( p, dir );	highp float c = dot( p, p ) - r * r;		highp float d = b * b - c;	if ( d < 0.0 ) {		return vec2( MAX, -MAX );	}	d = sqrt( d );		return vec2( -b - d, -b + d );}vec3 extractCameraPos(mat4 m){	mat3 rotMat = mat3(m);  	vec3 d = m[3].xyz;   	vec3 retVec = -d * rotMat; 	 return retVec;}float hash( float n ) { return fract(sin(n)*123.456789); }vec2 rotate( in vec2 uv, float a){    float c = cos( a );    float s = sin( a );    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );}//Spherical coordinates, very heavy deformation on the polesvec3 sphproj(in vec3 p){	//p = normalize(p);    //vec2 sph = vec2(acos(p.y/length(p))/PI, atan(p.z,p.x)/PI2);    //return vec3(sph,0.0);	float u = (atan(p.x, p.z) + PI) / TWOPI,                  v= (asin(p.y)) / PI+PI2;	return vec3(u,v,0.0);}// ray directionvec3 ray_dir( float fov, vec2 size, vec2 pos ) {	vec2 xy = pos - size * 0.5;	float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );		float z = size.y * 0.5 * cot_half_fov;		return normalize( vec3( xy, -z ) );}float light(in vec3 pos, in vec3 norm){	vec3 d = sun_position - pos;	return dot(normalize(d),norm);}// Mie// g : ( -0.75, -0.999 )//      3 * ( 1 - g^2 )               1 + c^2// F = ----------------- * -------------------------------//      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)float phase_mie( float g, float c, float cc ) {	float gg = g * g;		float a = ( 1.0 - gg ) * ( 1.0 + cc );	float b = 1.0 + gg - 2.0 * g * c;	b *= sqrt( b );	b *= 2.0 + gg;			return 1.5 * a / b;}// Reyleigh// g : 0// F = 3/4 * ( 1 + c^2 )float phase_reyleigh( float cc ) {	return 0.75 * ( 1.0 + cc );}float density( vec3 p ){	return exp( -( length( p ) - R_INNER ) * SCALE_H );}float optic( vec3 p, vec3 q ) {	vec3 step = ( q - p ) / FNUM_OUT_SCATTER;	vec3 v = p + step * 0.5;		float sum = 0.0;	for ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {		sum += density( v );		v += step;	}	sum *= length( step ) * SCALE_L;		return sum;}vec4 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {	float len = ( e.y - e.x ) / FNUM_IN_SCATTER;	vec3 step = dir * len;	vec3 p = o + dir * e.x;	vec3 v = p + dir * ( len * 0.5 );	vec4 sum = vec4( 0.0 );	for ( int i = 0; i < NUM_IN_SCATTER; i++ ) {		vec2 f = ray_vs_sphere( v, l, R );		vec3 u = v + l * f.y;				float n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );				sum += density( v ) * exp( -n * ( K_R * C_R + K_M ) );		v += step;	}	sum *= len * SCALE_L;		float c  = dot( dir, -l );	float cc = c * c;		return sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E;}void main(){	Sphere in_planet = Sphere(position,rotation,inner_radius,vec4(1.0));	Sphere out_planet = Sphere(position,rotation,outer_radius,vec4(1.0));	vec2 tc = vec2(texCoords.x,texCoords.y*iResolution.y/iResolution.x);	// default ray dir	vec3 dir = ray_dir( 66.0,vec2(1.0,iResolution.y/iResolution.x), tc);//texCoords.xy );	mat3 rot = mat3(inverse(view));	dir = rot * dir;	// default ray origin	//vec3 eye = vec3( 0.0, 0.0, 5.0 );	vec3 eye =  extractCameraPos(view);	Ray ray = Ray(eye, normalize(dir));	vec2 out_query = ray_vs_sphere( ray.o-in_planet.pos, ray.d, out_planet.rad ) ;	if(out_query.x>out_query.y)discard;	else{		vec2 in_query = ray_vs_sphere( ray.o-in_planet.pos, ray.d, in_planet.rad ) ;		vec4 col = vec4(0.0);		if(in_query.x<=in_query.y){			vec3 pos = ray.o + in_query.x*ray.d;			pos = in_planet.rot * pos;			vec3 norm = normalize(pos - in_planet.pos);			norm = in_planet.rot*norm;			vec2 uvs = sphproj(norm).xy;			//vec3 n = normal(uvs);			//float b = dot(n, vec3(0,1,0));			float b = 1.0;			//float b=1.0;			float l = light(pos,norm)+b*0.25;			l = max(l,0.1);			col = texture2D(texture,uvs)*vec4(l,l,l,1);//+vec4(out_t,0.0,0.0,1.0);		}				out_query.y = min( out_query.y, in_query.x );		vec4 I = in_scatter( ray.o-in_planet.pos, ray.d, out_query, normalize(sun_position-in_planet.pos) );		fragColor = I+col;	}	}