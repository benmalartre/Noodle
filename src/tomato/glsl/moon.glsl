// Original code by GLtracy#version 330uniform float iGlobalTime;uniform vec2 iResolution;uniform mat4 view;uniform vec3 position;uniform float inner_radius;uniform float outer_radius;uniform mat3 rotation;uniform vec3 color;uniform sampler2D texture;uniform vec3 sun_position;in vec2 texCoords;out vec4 fragColor;// math constconst float PI = 3.14159265359;const float PI2 = PI*0.5;const float TWOPI = 2*PI;const float DEG_TO_RAD = PI / 180.0;const float MAX = 10000.0;const int star_iterations = 3;const vec3 col_star = vec3( 0.77,1.0, 1.0 );const vec3 pos_star = vec3( 0.0, 0.0, 0.0 );const vec3 world_up = vec3( 0.0, 1.0, 0.0 );#define EPS 0.0001#define SAMPLES 8#define OFFSET_X .005#define OFFSET_Y .005#define DEPTH	  15.vec3 sample(float x, float y, in vec2 uv){	return texture2D(texture, uv + vec2(x,y)).xyz;}float luminance(vec3 c){	return dot(c, vec3(.2126, .7152, .0722));}vec3 normal(in vec2 uv){	float R = abs(luminance(sample( OFFSET_X,0., uv)));	float L = abs(luminance(sample(-OFFSET_X,0., uv)));	float D = abs(luminance(sample(0., OFFSET_Y, uv)));	float U = abs(luminance(sample(0.,-OFFSET_Y, uv)));				 	float X = (L-R) * .5;	float Y = (U-D) * .5;	return normalize(vec3(X, Y, 1. / DEPTH));}struct Ray {    vec3 o; //origin    vec3 d; //direction (should always be normalized)};struct Sphere {    vec3 pos;   //center of sphere position    mat3 rot;    float rad;  //radius    vec4 col;   //surface color};// angle : pitch, yawmat3 rot3xy( vec2 angle ) {	vec2 c = cos( angle );	vec2 s = sin( angle );		return mat3(		c.y      ,  0.0, -s.y,		s.y * s.x,  c.x,  c.y * s.x,		s.y * c.x, -s.x,  c.y * c.x	);}Sphere in_planet = Sphere(position,rotation,inner_radius,vec4(1.0));Sphere out_planet = Sphere(position,rotation,outer_radius,vec4(1.0));/* ---------- Object intersection functions ---------- */float intersectSphere(in Ray ray, in Sphere sphere){    vec3 oc = ray.o - sphere.pos;    float b = 2.0 * dot(ray.d, oc);    float c = dot(oc, oc) - sphere.rad*sphere.rad;    float disc = b * b - 4.0 * c;    if (disc < 0.0)        return -1.0;    // compute q as described above    float q;    if (b < 0.0)        q = (-b - sqrt(disc))/2.0;    else        q = (-b + sqrt(disc))/2.0;    float t0 = q;    float t1 = c / q;    // make sure t0 is smaller than t1    if (t0 > t1) {        // if t0 is bigger than t1 swap them around        float temp = t0;        t0 = t1;        t1 = temp;    }    // if t1 is less than zero, the object is in the ray's negative direction    // and consequently the ray misses the sphere    if (t1 < 0.0)        return -1.0;    // if t0 is less than zero, the intersection point is at t1    if (t0 < 0.0) {        return t1;    } else {        return t0;     }}vec3 extractCameraPos(mat4 m){	mat3 rotMat = mat3(m);  	vec3 d = m[3].xyz;   	vec3 retVec = -d * rotMat; 	 return retVec;}float hash( float n ) { return fract(sin(n)*123.456789); }vec2 rotate( in vec2 uv, float a){    float c = cos( a );    float s = sin( a );    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );}//Spherical coordinates, very heavy deformation on the polesvec3 sphproj(in vec3 p){	//p = normalize(p);    //vec2 sph = vec2(acos(p.y/length(p))/PI, atan(p.z,p.x)/PI*0.5);    //return vec3(sph,0.0);	float u = -(atan(p.x, p.z) + PI) / TWOPI,                  v= (asin(p.y/length(p)) + PI2) / PI;	return vec3(-u,-v,0.0);}// ray directionvec3 ray_dir( float fov, vec2 size, vec2 pos ) {	vec2 xy = pos - size * 0.5;	float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );		float z = size.y * 0.5 * cot_half_fov;		return normalize( vec3( xy, -z ) );}// ray intersects sphere// e = -b +/- sqrt( b^2 - c )vec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {	float b = dot( p, dir );	float c = dot( p, p ) - r * r;		float d = b * b - c;	if ( d < 0.0 ) {		return vec2( MAX, -MAX );	}	d = sqrt( d );		return vec2( -b - d, -b + d );}float light(in vec3 pos, in vec3 norm){	vec3 d = sun_position - pos;	return dot(normalize(d),norm);}void main(){	vec2 tc = vec2(texCoords.x,texCoords.y*iResolution.y/iResolution.x);	// default ray dir	vec3 dir = ray_dir( 66.0,vec2(1.0,iResolution.y/iResolution.x), tc);//texCoords.xy );	mat3 rot = mat3(inverse(view));	dir = rot * dir;	// default ray origin	//vec3 eye = vec3( 0.0, 0.0, 5.0 );	vec3 eye =  -view[3].xyz;//extractCameraPos(view);	Ray ray = Ray(eye, normalize(dir));	float t = intersectSphere(ray, in_planet);	if(t<=EPS)discard;	else{		vec3 pos = ray.o + t*ray.d;		pos = in_planet.rot * pos;		vec3 norm = normalize((pos - in_planet.pos)/in_planet.rad);		//norm = in_planet.rot*norm;		vec2 uvs = sphproj(norm).xy;		vec3 n = normal(uvs);		float b = dot(n, vec3(0,1,0));		float l = light(pos,norm);		l = max(l,0.1);		fragColor = texture2D(texture,uvs)*vec4(l,l,l,1);		//fragColor = texture2D(iChannel1,uvs);		//fragColor = vec4(uvs,0.0,1.0);	}	}